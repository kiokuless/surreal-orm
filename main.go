package main

import (
	"encoding/json"
	"fmt"
	"go/ast"
	"os"
	"strings"

	"golang.org/x/tools/go/analysis"
	"golang.org/x/tools/go/analysis/passes/inspect"
	"golang.org/x/tools/go/analysis/singlechecker"
	"golang.org/x/tools/go/ast/inspector"

	. "github.com/dave/jennifer/jen"
)

var surrealTagAnalyzer = &analysis.Analyzer{
	Name: "surrealtag",
	Doc:  "generates code for surreal struct tags",
	Run:  run,
	Requires: []*analysis.Analyzer{
		inspect.Analyzer,
	},
}

func run(pass *analysis.Pass) (interface{}, error) {
	inspect := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

	nodeFilter := []ast.Node{
		(*ast.TypeSpec)(nil),
	}

	inspect.Preorder(nodeFilter, func(n ast.Node) {
		typeStmt := n.(*ast.TypeSpec)
		// return if not struct
		structType, ok := typeStmt.Type.(*ast.StructType)
		if !ok {
			return
		}

		// get package name
		packageName := pass.Pkg.Name()
		structName := typeStmt.Name.Name
		fields := []*ast.Field{}
		for _, field := range structType.Fields.List {
			if field.Tag != nil {
				tag := strings.Trim(field.Tag.Value, "`")
				if strings.Contains(tag, `surreal:`) {
					fields = append(fields, field)
				}
			}
		}
		if 0 < len(fields) {
			generatedCode := generateStructByFields(packageName, structName, fields)
			filename := pass.Fset.File(n.Pos()).Name()
			newFilename := strings.Replace(filename, ".go", ".surreal.generated.go", 1)
			file, err := os.Create(newFilename)
			if err != nil {
				panic(err)
			}
			defer file.Close()
			file.Write([]byte(generatedCode))
			fmt.Println("generated: " + newFilename)
		}
	})

	return nil, nil
}

func generateStructByFields(packageName, structName string, fields []*ast.Field) string {
	f := NewFile(packageName)
	f.Comment("Code generated by surrealtag; DO NOT EDIT.")
	fieldDecls := []Code{}
	for _, field := range fields {
		fieldName := field.Names[0].Name
		// get surreal tag value
		tag := strings.Trim(field.Tag.Value, "`")
		tag = strings.Replace(tag, `surreal:`, "", 1)
		tag = strings.Replace(tag, `"`, "", -1)
		jsonName := strings.Split(tag, ",")[0]
		fieldDecls = append(fieldDecls, Id(fieldName).Id("strandJSON").Tag(map[string]string{"json": jsonName}))
	}

	decapitalizedStructName := strings.ToLower(string(structName[0])) + structName[1:]
	f.Type().Id(decapitalizedStructName + "JSON").Struct(fieldDecls...)
	f.Type().Id("strandJSON").Struct(Id("Strand").String().Tag(map[string]string{"json": "Strand"}))

	block := []Code{Id("s").Op(":=").Id(structName).Values()}
	for _, field := range fields {
		fieldName := field.Names[0].Name
		block = append(block, Id("s").Dot(fieldName).Op("=").Id("j").Dot(fieldName).Dot("Strand"))
	}
	block = append(block, Return(Id("s")))

	f.Func().Id("from" + decapitalizedStructName + "JSON").Params(Id("j").Id(decapitalizedStructName + "JSON")).Id(structName).Block(
		block...,
	)

	f.Type().Id("objectJSON").Struct(Id("Inner").Id(decapitalizedStructName + "JSON").Tag(map[string]string{"json": "Object"}))

	return fmt.Sprintf("%#v", f)
}

func main() {
	jsonBytes := []byte(`{
		"Object": {
			"requested_at": {
				"Strand": "2024-01-19T16:29:08.182623+09:00"
			},
			"responded_at": {
				"Strand": "2024-01-19T16:29:08.331045+09:00"
			}
		}
	}`)
	var r objectJSON
	err := json.Unmarshal(jsonBytes, &r)
	if err != nil {
		panic(err)
	}

	record := fromrecordJSON(r.Inner)
	fmt.Printf("%#v\n", record)
	singlechecker.Main(surrealTagAnalyzer)
}
